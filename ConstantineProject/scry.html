<!DOCTYPE html>
<html>

<head>

	<title>Scry</title>

	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0">

	<script src="./js/leaflet-src.js"></script>
	<script src="./js/leaflet-sidebar.js"></script>
	<script src="./js/timeline.js"></script>

	<link rel="stylesheet" href="./css/leaflet.css" />
	<link rel="stylesheet" href="./css/leaflet-sidebar.css" />
	<link rel="stylesheet" href="./css/timeline.css" />

	<link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">
	<link rel="shortcut icon" type="image/x-icon" href="./images/coin.s.png" />

	<style>
		html,
		body {
			height: 100%;
			margin: 0;
		}

		#map {
			width: 100%;
			height: 93%;
		}

		.leaflet-container {
			background-color: rgb(176, 220, 242);
		}
	</style>


</head>

<body>
	<div id="sidebar" class="sidebar collapsed">
		<!-- Nav tabs -->
		<div class="sidebar-tabs">
			<ul role="tablist">
				<li><a href="#home" role="tab"><img src="./images/coin.s.png" height = "40px" width = "40px"></img></a></li>
				<li><a href="#profile" role="tab"><i class="fa fa-user"></i></a></li>
				<li><a href="#somethingelse" role="tab"><i class="fa fa-envelope"></i></a></li>
			</ul>

			<ul role="tablist">
				<li><a href="#settings" role="tab"><i class="fa fa-gear"></i></a></li>
			</ul>
		</div>

		<!-- Tab panes -->
		<div class="sidebar-content">
			<div class="sidebar-pane" id="home">
				<h1 class="sidebar-header">
							  <div class ="shader"><b>CONSTANTINE</b></div>
	              <span class="sidebar-close"><i class="fa fa-caret-left"></i></span>
	          </h1>
				<div class="paper">
					<p class="lorem">
						Constantine: From Rome to Byzantium is leaflet-based web application which showcases an interactive historical narrative. Constantine is built with Scry, a technology which visualizes the causal linkage between historical events, which can then be explored
						at the discretion of the user.
					</p>
				</div>
			</div>

			<div class="sidebar-pane" id="profile">
				<h1 class="sidebar-header">
							<div class = "shader">Profile</div>
							<span class="sidebar-close"><i class="fa fa-caret-left"></i></span>
						</h1>
				<div class="paper">
					<p>Information about your profile goes here</p>
				</div>
			</div>

			<div class="sidebar-pane" id="somethingelse">
				<h1 class="sidebar-header">
							<div class = "shader">Somethingelse</div>
							<span class="sidebar-close"><i class="fa fa-caret-left"></i></span>
						</h1>
				<div class="paper">
					<p>Something else can go here</p>
				</div>
			</div>

			<div class="sidebar-pane" id="settings">
				<h1 class="sidebar-header">
							<div class = "shader">Settings</div>
							<span class="sidebar-close"><i class="fa fa-caret-left"></i></span>
						</h1>
				<div class="paper">
					<p>Select your desired settings here</p>
				</div>
			</div>
		</div>
	</div>

	<div id='map' class='sidebar-map'></div>
	<div id='timeline-background' class='timeline-background'>
		<div id = 'timeline-wrapper' class = 'timeline-wrapper'>
			<input type="range" name="time" min="0" max="0" value="0" class="slider" id="slide">
			<div id="bubble-wrapper" class = 'bubble-wrapper'>
				<div id="bubble" class = 'bubble'></div>
			</div>
		</div>
	</div>
	</div>

	<script src="./geo/provinces.js" type="text/javascript"></script>
	<script src="./geo/rivers.js" type="text/javascript"></script>
	<script src="./geo/lakes.js" type="text/javascript"></script>

	<script src="./geo/land.js" type="text/javascript"></script>

	<script>
		// Set slide
		var mapPeriod = [267,330];
		var mapYear = mapPeriod[0];
		document.getElementById('slide').min = mapPeriod[0];
		document.getElementById('slide').max = mapPeriod[1];
		document.getElementById('slide').value = mapYear;
		// Set the bounds of the map
		bounds = new L.LatLngBounds(new L.LatLng(20, -50), new L.LatLng(70, 60));

		var map = new L.map('map', {
			maxBounds: bounds,
			maxBoundsViscosity: 0.7,
			zoomSnap: 0.5,
			minZoom: 4.5,
			maxZoom: 6
		}).setView([40, 20], 4);
		// Some styles...
		var lndStyle = {
			"color": "#ffefdc",
			"weight": 0,
			"fillOpacity": 1.0
		};

		var wtrStyle = {
			"color": "#3BF",
			"weight": 2,
			"fillOpacity": 1.0
		};


		var polStyle = {
			"color": "#FF0000",
			"weight": 0,
			"fillOpacity": 0.3
		};

		/*
		var lndLyr = L.geoJSON(lnd, {
			style: lndStyle
		}).addTo(map);

		*/

		var Stamen_Watercolor = L.tileLayer('https://stamen-tiles-{s}.a.ssl.fastly.net/watercolor/{z}/{x}/{y}.{ext}', {
			attribution: 'Map tiles by <a href="http://stamen.com">Stamen Design</a>, <a href="http://creativecommons.org/licenses/by/3.0">CC BY 3.0</a> &mdash; Map data &copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>',
			subdomains: 'abcd',
			ext: 'png'
		}).addTo(map);

		pol = polData[267]; // polData is defined in geo/provinces.js - a JSON weird object...
		// Set Political Layer - based on pol (data) and polStyle
		var polLyr = L.geoJSON(pol, {
			style: polStyle
		}).addTo(map);

		// Set Water Layer - based on rvr (data) and wtrStyle
		var wtrLyr = L.geoJSON(rvr, {
			style: wtrStyle
		}).addTo(map);

		// All Agents
		var agents = [];
		getAgentsFromServer();

		var timeline = document.getElementById("slide");
		initBubble();
		var yearTracker = document.getElementById("yearTracker");

		var sidebar = L.control.sidebar('sidebar').addTo(map);

		var currentPopupFrame = null;
		var currentPopupName = null;
		var currentPopup = null;
		// Agents Graph
		var agentsGraph = null;

		// Receive messages from other windows.
		window.addEventListener("message", receiveMessage, false);

		// Move the slide to the current year/
		updateYear();

		function receiveMessage(event) {

			if (event.data == "current") {
				currentPopupFrame.contentWindow.postMessage(currentPopup.profile, '*');
			} else { // else, we're sending the name of an agent we need "to go" to.

				agent = findAgent(event.data);
				//console.log(event.data);
				//console.log(agent);
				let target = agent.marker; //findAgent(event.data).marker;
				//console.log(target);
				timeline.value = agent.profile.yearRange[0];
				updateYear(); // otherwise, it doesn't work. Needs to be on the same year.

				target.openPopup();




			}
		}

		/** 
		@description Finds a match for the given agent.  
 		*/ 
		function findAgent(name, type = 'city') {
				let match = agents.find(function(agent) {
					return agent.profile.name == name;
				});
				return match;
		}


		function getAgentsFromServer() {
			let path = ("./agents/agents.json");
			let xhttp = new XMLHttpRequest();
			xhttp.onreadystatechange = function() {
				if (this.readyState == 4 && this.status == 200) {
					let data = JSON.parse(this.responseText);

					addAgents(data);

					updateAgents();
				}
			};
			xhttp.open("GET", path, true);
			xhttp.send();
		}

		function addAgents(data) {
			
			// I'll need this to test some things out... 
			agentsGraph = new AgentsGraph();
			console.log('Created agentsGraph');

			data.forEach(function(element) {
				let a;

				if (element.type=='city' || element.type=='City') {
					setupCity(element);
				}else if (element.type=='person' || element.type=='Person') {
					setupPerson(element);
				}else if (element.type=='event' || element.type=='Event') {
					setupEvent(element);
				}

				// I'll need this to test some things out too... haha
				agentsDummyDatabase.set(element.name, element); // same as Agents, but I access with the name. Unnecessary because we have findAgents().
				agentsGraph.addVertex(element.name);
				

			});
			
			// ** Will do this manually **FOR NOW** but need to figure it out properly later**
			// I just wanna see how the agentsGraph data structure looks like
			agentsGraph.addAdjacentAgent('Constantine Hailed as Emperor','Rome');
			agentsGraph.addAdjacentAgent('Constantine Hailed as Emperor','Constantinople');
			//agentsGraph.addAdjacentAgent('Constantine Hailed as Emperor', 'Eboracum'); // Not actually modeled as a city yet...
			agentsGraph.addAdjacentAgent('Edict of Milan','Rome');
			//agentsGraph.addAdjacentAgent('Constantine', 'Milan'); // Not actually modeled as a city yet...
			agentsGraph.addAdjacentAgent('Edict of Milan', 'Constantinople');
			//agentsGraph.addAdjacentAgent('Constantinople','Edict of Milan');
			agentsGraph.addAdjacentAgent('Rome','Constantinople');
			// want to relate edict of milan to linicius
			// want to relate edict of milan to milan
			// want to relate linicius to rome
			// want to relate linicius to milan.
			// just to have toy data...


			// Let's also add some subsequent events
			agentsGraph.addAdjacentAgent('Constantine Hailed as Emperor','Edict of Milan',true);

			// Let's how that graph looks like...
			console.log(agentsGraph);
			console.log(agents);
			console.log(agentsDummyDatabase);



		}

		/** 
		@description Sets up icon, popupAnchor, marker, pushes agent to Agents, and creates timeline event.
 		*/
		function setupEvent(element) {

			if (!element.iconSize){
				element.iconSize = [70,70];
			}
			if(!element.popupAnchor){
				element.popupAnchor = [0, -35];
			}

			let m = setupWithMarker(element, 20);

			let a = new Event(element.name, element.content,m,element.yearRange);

			agents.push(a);

			createTimelineEvent(a.profile.yearRange[0], element.name);

			setupWithMarker(element);
		}

		/** 
		@description Sets up icon, popupAnchor, marker, and pushes agent to Agents.
 		*/
		function setupCity(element) {
			if (!element.iconSize){
				element.iconSize = [70,70];
			}
			if(!element.iconAnchor){
				element.iconAnchor = [35,60];
			}
			if(!element.popupAnchor){
				element.popupAnchor = [0, -70];
			}
			let m = setupWithMarker(element);

			let a = new City(element.name, element.content,m,element.yearRange);

			agents.push(a);
		}

		/** 
		@description Sets up icon, popupAnchor, marker, and pushes agent to Agents.
 		*/
		function setupPerson(element) {

			if (!element.iconSize){
				element.iconSize = [70,70];
			}
			if(!element.iconAnchor){
				element.iconAnchor = [35,35];
			}
			if(!element.popupAnchor){
				element.popupAnchor = [0, -40];
			}

			let m = setupWithMarker(element, 10);

			let a = new Person(element.name, element.content,m,element.yearRange);

			agents.push(a);
		}

		/** 
		@description .
 		*/
		function setupWithMarker(element, zOffset = 0) {
			let icon = L.icon({
				iconUrl: element.iconUrl,
				iconSize: element.iconSize,
				iconAnchor: element.iconAnchor,
				popupAnchor: element.popupAnchor
			});
			let m = L.marker(element.coordinates, {
				icon,
				zIndexOffset: zOffset
			});

			m.bindPopup((L.popup({
				lazyload: '<iframe id = "'+element.name+'" src="./agents/agent.html"></iframe>'
			})));

			/*if (element.type == 'city') {
				m.bindTooltip(element.name, { permanent: true, opacity:0.9 });
			}*/
			return m;
		}

		/*
		L.geoJSON(names, {
		}).addTo(map);
		*/
		map.on('popupopen', function(e) {

			console.log('popupopen!');
			console.log(e);
			let popen = e.popup;
			if (popen.options.lazyload) {
				popen.setContent(popen.options.lazyload);
				// *** little experiment here *************************
				console.log(popen.options.lazyload)

				popen.setContent(popen.options.lazyload += '<div><p>Hello World</p></div>');
				// *****************************************************
				currentPopupFrame = popen._contentNode.firstChild;
				currentPopupName = currentPopupFrame.id;
				//***
				console.log(currentPopupName); // Will need this for a second.
				//***
				currentPopup = findAgent(currentPopupName);
			}
		});

		timeline.oninput = updateYear; // interesting...

		/** 
		@description Updates mapYear value and calls updateAgents(). And also updates political layer.
 		*/
		function updateYear() {
			mapYear = timeline.value;
			yearTracker.innerHTML = "Year: " + mapYear + "AD";
			updateAgents();

			//remove every layer which polLyr contains from the map
			Object.keys(polLyr._layers).forEach(function(key) {
				element = polLyr._layers[key];
  			map.removeLayer(element);
			});

			//assign new GeoJSON data to pol, based on the current year
			pol = polData[mapYear]

			//if the new data is a reference to another year, use the data from that year instead
			while (typeof pol == 'number') {
				pol = polData[pol]
			}

			//recreate polLyr with the new data in pol
			polLyr = L.geoJSON(pol, {
				style: polStyle
			})

			//re-add polLyr to the map
			polLyr.addTo(map)

		}

		/** 
		@description Pretty much places/remove markers depending whether the agent exists between the year range..
 		*/
		function updateAgents() {
			agents.forEach(function(a) {
				if(a.marker._latlng){
					if(a.profile.yearRange[0]<=mapYear && a.profile.yearRange[1]>=mapYear) {
						a.marker.addTo(map);
					}else{
						a.marker.remove();
					}
				}
			});
		}


		// CLASSES
		class Agent {
			constructor(name, content,type=null, yearRange=[-4000,3000]) {
				this.profile = new Profile(name,content,type,yearRange);
			}
		}

		class Profile {
			constructor(name,content,type=null, yearRange=[-4000,3000]) {
				this.name = name;
				this.content = content;
				this.type = type;
				this.yearRange = yearRange;
			}
		}

		class City extends Agent {
			constructor(name, content, marker,yearRange){
				super(name, content, 'City',yearRange);
				this.marker = marker;
			}
		}

		class Person extends Agent {
			constructor(name, content, marker,yearRange){
				super(name, content, 'Person',yearRange);
				this.marker = marker;
			}
		}

		// class Event { // shouldn't Event extend Agent?
		// 	constructor(name, content,marker,yearRange=[-4000,3000]) {
		// 		// I was wondering if the line below could be super(name,content,'Event',yearRange);
		// 		this.profile = new Profile(name,content,'Event',yearRange);
		// 		this.type = 'Event'; // doesn't profile contain an attribute for type?
		// 		this.marker = marker;
		// 	}
		// }
		class Event extends Agent {
			constructor(name, content, marker, yearRange=[-4000,3000]){
				super(name, content, 'Event', yearRange);
				this.marker = marker;
			}
		}



		class Graph {

			constructor() {
				this.AdjList = new Map();
			}

			addVertex(vertex) {
				// Remember that AdjList is a javascript Map (a dictionary)
				// So we use the vertex as the key. The adjacency list (of more vertices) is the value.
				this.AdjList.set(vertex, [])
				
			}

			addUndirectedEdge(vertex1, vertex2) {
				// vertx1 towards vertex2
				this.AdjList.get(vertex1).push(vertex2);
				// vertex2 towards vertex1, as graph is undirected.
				this.AdjList.get(vertex2).push(vertex1);
			}

			addDirectedEdge(fromVertex, toVertex){
				// fromVertex towards toVertex
				this.AdjList.get(fromVertex).push(toVertex);
			}

			neighbors(vertex) {

				return this.AdjList.get(vertex);
			}


		}


		var agentsDummyDatabase = new Map();
		class AgentsGraph extends Graph {


			retrieveAgentFromDatabase(agentID){
				// I could have done this with Agents object. Unnecessary to use the dummy db
				return agentsDummyDatabase.get(agentID);
				// return Agents.get(agentID); // or something like that
			}

			adjacentAgents(agentID, type=null) {
				
				// List of adjacent agents that will be returned
				var adjAgentsList = []
				
				// We iterate adjacency list of the vertex 
				for (var i = 0, size = super.neighbors(agentID).size; i < size; i++) {
					
					// With the adjAgentID
					adjAgentID =  super.neighbors(agentID)[i];
					// We can retrieve Agent Object from database
					adjAgent = retrieveAgentFromDatabase(adjAgentID);


					if ( adjAgent.type == type || type == null){
						adjAgentsList.push(adjAgent)
					}
				}

				return adjAgentsList; // these are actual Agent objects.
		
				
			}


			// I think that I'll get rid of this function and just use the corresponding method(s) from the parent class...
			addAdjacentAgent(agentID, adjAgentID, directedRelation = false) {

				if (directedRelation == false){
					super.addUndirectedEdge(agentID, adjAgentID);
				} else {
					// implement code for directed edges in Graph class
					super.addDirectedEdge(agentID,adjAgentID);
				}
			}


		}





	</script>



</body>

</html>
